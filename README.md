# Smart City
Smart City web app is a simulation app which intention is to be a show case of some different technologies (Geographic calculation, web socket, multi-threading). 

Below is the problem description for the application:

The city of London has implemented a robot that moves through a predetermined route every
morning, collecting pollution data at fixed intervals, and reporting them.
The goal of this exercise is to implement code that would control such robot, within the following
guidelines:
- Every morning an operator feeds the robot with the polyline (taken from Google) with
the route of the robot (see polyline below).
- The robot will move along the points of the polyline.
- Acceptable speed for the robot is between 1 and 3 meters per second
- Every 100 meters, the robot “reads” the level of PM2.5 particles in the location.
- Values of PM2.5 will be in the following range:
- 0 to 50: Good
- 51 - 100: Moderate
- 101 - 150: USG (Unhealthy to Sensitive Groups)
- > 150: Unhealthy
- Of course this can be randomly generated at each stop
- Every 15 minutes the robot reports the average of all new readings since the last one
and reports according to the grouping above. The output should be a json like:
`{“timestamp”: 1528106219,“location”: {“lat”: 51.23241, “lng”: -0.1223},“level”: “USG”,“source”: “robot”}`

# Technologies used
Smart city web app is using [SpringBoot 2.0.2](https://projects.spring.io/spring-boot/), [Google Maps Services](https://github.com/googlemaps/google-maps-services-java), [Stomp Web Socket](https://github.com/jmesnil/stomp-websocket) and [HikariCP](https://github.com/brettwooldridge/HikariCP).

## Abstract

The functional objective of the App is:

  * Provide useful information about the readings according to the problem description.

The technical requirements for this service should include:

  * Easy to maintain - functionality should be broken in small pieces, so they can easily be:
  * dettached
  * changed
  * enhanced
  * scaled

## **Dependency-Injection**

Using Spring DI to create Singleton and Scope based components that can be injected into other classes.

## **Logging**

The Logback logger is configured for a better output and contains a rolling file
appender. The logs look like:

`2018-06-20 02:26:43.765  INFO 6577 --- [           main] c.d.core.SmartCityCoreApiWebApp      : Started SmartCityCoreApiWebApp in 6.598 seconds (JVM running for 6.983)`

## **Transformation (DTOs)**

Uses Orika to transform a singular or collection based Data Transfer Objects to Application Entities (and in reverse) `@Service`.

## **Health Checks**

Leverages [Spring Boot Actuator](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html) to provide application metrics via standard endpoint names.

For example: `/health`

## **Interactive API Documentation** (TODO)

API Documentation is automatically generated by [Springfox Spring Swagger2 Plugin](https://springfox.github.io/springfox/docs/snapshot/) on every build. It will automatically scan all specified Controllers, Models and Services and generate Swagger 2 markup. Leverage Springfox Swagger Annotations in your code to further decorate the Swagger markup with descriptions, notes, expected HTTP response codes etc.

To access the auto-generated Swagger Documentation, start your application and access the [Swagger UI](localhost:8080/swagger-ui.html) in your browser.

For example usages of the Springfox Swagger Annotations, see `HealthController.java`.

## **Testing**

Unit and Integration tests are provided within every Maven module. Each test uses [JUnit 4.12](http://junit.org/junit4/) in conjunction with the [Spring Test](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/integration-testing.html) `SpringJUnit4ClassRunner` and is run on every automated build.

## **Application Build & Deployment**

Before you begin, be sure to have the following installed on your build machine:

  * Java JDK 1.8 with a minimum version of 1.8.0-30 and maximum version of 1.8.0-60
    * Run the `java -version` command to determine if the correct Java JDK is installed
  * Maven 3 with a minimum version of 3.1.0 and a maximum version of 3.3.9
    * Run the `mvn -version` command to determine if the correct version of Maven 3 is installed

### **Available Build Profiles** (TODO)

  * **local** - Local Developer Machine
  * **development** - AWS Development Elastic Beanstalk
  * **qa** - AWS QA Elastic Beanstalk
  * **production** - AWS Production Elastic Beanstalk

### **Instructions**

##### **Maven CLI**

  1. If you are not on a Linux based OS, open a Terminal window (if you are on OSX) or CMD (if you are on Windows).
  2. Navigate to the directory that contains the project.
    * **For example:** `cd /Users/testytesterson/Development/[project-dir]`
  3. Add the Profile for the environment you want to build to using the Maven -P (Profile) flag.
    * **For example:** `mvn -Pdevelopment clean install`
  4. Deploy the generated .jar to the desired server
  
## **JavaDoc Generation**

If you want to automatically generate JavaDoc HTML as part of the build process, you can use the chainable `release` Maven profile in addition to the environment Maven profile.

**For example:** `mvn -Pdevelopment,release clean package`

Generated JavaDocs for all modules will be automatically aggregated to the top level target folder under site -> apidocs -> index.html

## **SonarQube Generation** (TODO)

If you want to automatically generate SonarQube reports as part of the build process, you can use the chainable `release` Maven profile in addition to the environment Maven profile.

**For example:** `mvn -Pdevelopment,release clean package`

Generated Sonar reports for all modules will be automatically aggregated to the top level target folder under site -> sonar

**NOTE:** You must set up your local .m2 settings to be pointed to your local or remote Sonar server. You will add a sonar profile to the settings.xml located within your .m2 folder with a setting similar to the below:

`        
<profile>  
    <id>sonar</id>  
    <activation>  
         <activeByDefault>false</activeByDefault>  
     </activation>  
     <properties>  
         <!-- Optional URL to server. Default value is http://localhost:9000 -->  
         <sonar.host.url>  
             http://localhost:9000  
         </sonar.host.url>  
     </properties>  
 </profile>  
`
#### **Github**

  1. Push Events
  2. Tag Push Events
  3. Issues Events
  4. Merge Request events
  5. Wiki Page events
  6. Notes
  
#### **Codeship**

##### Tests

Setup Commands

```
# Set Java Version  
jdk_switcher home oraclejdk8  
jdk_switcher use oraclejdk8  
```

Configure Test Pipelines

```
# Maven
mvn clean test
```

##### Deployment Pipeline
Create a Deployment Pipeline with the following custom script:
  
```
# Set Java Version 
jdk_switcher home oraclejdk8  
jdk_switcher use oraclejdk8

# Install AWS CLI  
pip install awsebcli==3.7.8

# Maven
mvn clean install -P development -Dmaven.test.skip=true
```

## **Sample API Calls**

Coming Soon!

Polyline example:

```
mpjyHx`i@VjAVKnAh@BHHX@LZR@Bj@Ml@WWc@]w@bAyAfBmCb@o@pLeQfCsDVa@@ODQR}AJ{A?{BGu
AD_@FKb@MTUX]Le@^kBVcAVo@Ta@|EaFh@m@FWaA{DCo@q@mCm@cC{A_GWeA}@sGSeAcA_EOSMa
@}A_GsAwFkAiEoAaFaBoEGo@]_AIWW{AQyAUyBQqAI_BFkEd@aHZcDlAyJLaBPqDDeD?mBEiA}@F]yKWqGSkI
CmCIeZIuZi@_Sw@{WgAoXS{DOcAWq@KQGIFQDGn@Y`@MJEFIHyAVQVOJGHgFRJBBCCSKBcAKoACyA?m@^y
VJmLJ{FGGWq@e@eBIe@Ei@?q@Bk@Hs@Le@Rk@gCuIkJcZsDwLd@g@Oe@o@mB{BgHQYq@qBQYOMSM
GBUBGCYc@E_@H]DWJST?JFFHBDNBJ?LED?LBv@WfAc@@EDGNK|@e@hAa@`Bk@b@OEk@Go@IeACoA@
a@PyB`@yDDc@e@K{Bi@oA_@w@]m@_@]QkBoAwC{BmAeAo@s@uAoB_AaBmAwCa@mAo@iCgAwFg@iD
q@}G[uEU_GBuP@cICmA?eI?qCB{FBkCI}BOyCMiAGcAC{AN{YFqD^}FR}CNu@JcAHu@b@_E`@}DVsB^mBTsAQ
KkCmAg@[YQOIOvAi@[m@e@s@g@GKCKAEJIn@g@GYGIc@ScBoAf@{A`@uAlBfAG`@
```
